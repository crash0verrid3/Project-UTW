#BlueJ class context
comment0.params=port
comment0.target=jProxy(int)
comment0.text=\r\n\tpublic\ static\ void\ main\ (String\ args[])\r\n\t{\r\n\t\tint\ port\ \=\ 0;\r\n\t\tString\ fwdProxyServer\ \=\ "";\r\n\t\tint\ fwdProxyPort\ \=\ 0;\r\n\t\t\r\n\t\tif\ (args.length\ \=\=\ 0)\r\n\t\t{\r\n\t\t\tSystem.err.println("USAGE\:\ java\ jProxy\ <port\ number>\ [<fwd\ proxy>\ <fwd\ port>]");\r\n\t\t\tSystem.err.println("\ \ <port\ number>\ \ \ the\ port\ this\ service\ listens\ on");\r\n\t\t\tSystem.err.println("\ \ <fwd\ proxy>\ \ \ \ \ optional\ proxy\ server\ to\ forward\ requests\ to");\r\n\t\t\tSystem.err.println("\ \ <fwd\ port>\ \ \ \ \ \ the\ port\ that\ the\ optional\ proxy\ server\ is\ on");\r\n\t\t\tSystem.err.println("\\nHINT\:\ if\ you\ don't\ want\ to\ see\ all\ the\ debug\ information\ flying\ by,");\r\n\t\t\tSystem.err.println("you\ can\ pipe\ the\ output\ to\ a\ file\ or\ to\ 'nul'\ using\ \\">\\".\ For\ example\:");\r\n\t\t\tSystem.err.println("\ \ to\ send\ output\ to\ the\ file\ prox.txt\:\ java\ jProxy\ 8080\ >\ prox.txt");\r\n\t\t\tSystem.err.println("\ \ to\ make\ the\ output\ go\ away\:\ java\ jProxy\ 8080\ >\ nul");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t//\ get\ the\ command-line\ parameters\r\n\t\tport\ \=\ Integer.parseInt(args[0]);\r\n\t\tif\ (args.length\ >\ 2)\r\n\t\t{\r\n\t\t\tfwdProxyServer\ \=\ args[1];\r\n\t\t\tfwdProxyPort\ \=\ Integer.parseInt(args[2]);\r\n\t\t}\r\n\t\t\r\n\t\t//\ create\ and\ start\ the\ jProxy\ thread,\ using\ a\ 20\ second\ timeout\r\n\t\t//\ value\ to\ keep\ the\ threads\ from\ piling\ up\ too\ much\r\n\t\tSystem.err.println("\ \ **\ \ Starting\ jProxy\ on\ port\ "\ +\ port\ +\ ".\ Press\ CTRL-C\ to\ end.\ \ **\\n");\r\n\t\tjProxy\ jp\ \=\ new\ jProxy(port,\ fwdProxyServer,\ fwdProxyPort,\ 20);\r\n\t\tjp.setDebug(1,\ System.out);\t\t//\ or\ set\ the\ debug\ level\ to\ 2\ for\ tons\ of\ output\r\n\t\tjp.start();\r\n\t\t\r\n\t\t//\ run\ forever;\ if\ you\ were\ calling\ this\ class\ from\ another\r\n\t\t//\ program\ and\ you\ wanted\ to\ stop\ the\ jProxy\ thread\ at\ some\r\n\t\t//\ point,\ you\ could\ write\ a\ loop\ that\ waits\ for\ a\ certain\r\n\t\t//\ condition\ and\ then\ calls\ jProxy.closeSocket()\ to\ kill\r\n\t\t//\ the\ running\ jProxy\ thread\r\n\t\twhile\ (true)\r\n\t\t{\r\n\t\t\ttry\ {\ Thread.sleep(3000);\ }\ catch\ (Exception\ e)\ {}\r\n\t\t}\r\n\t\t\r\n\t\t//\ if\ we\ ever\ had\ a\ condition\ that\ stopped\ the\ loop\ above,\r\n\t\t//\ we'd\ want\ to\ do\ this\ to\ kill\ the\ running\ thread\r\n\t\t//jp.closeSocket();\r\n\t\t//return;\r\n\t}\r\n\t\r\n\t/*\ the\ proxy\ server\ just\ listens\ for\ connections\ and\ creates\r\n\ a\ new\ thread\ for\ each\ connection\ attempt\ (the\ ProxyThread\r\n\ class\ really\ does\ all\ the\ work)\r\n
comment1.params=port\ proxyServer\ proxyPort
comment1.target=jProxy(int,\ java.lang.String,\ int)
comment2.params=port\ proxyServer\ proxyPort\ timeout
comment2.target=jProxy(int,\ java.lang.String,\ int,\ int)
comment3.params=level\ out
comment3.target=void\ setDebug(int,\ java.io.PrintStream)
comment3.text=\ allow\ the\ user\ to\ decide\ whether\ or\ not\ to\ send\ debug\r\n\ output\ to\ the\ console\ or\ some\ other\ PrintStream\r\n
comment4.params=
comment4.target=int\ getPort()
comment4.text=\ get\ the\ port\ that\ we're\ supposed\ to\ be\ listening\ on\r\n
comment5.params=
comment5.target=boolean\ isRunning()
comment5.text=\ return\ whether\ or\ not\ the\ socket\ is\ currently\ open\r\n
comment6.params=
comment6.target=void\ closeSocket()
comment6.text=\ closeSocket\ will\ close\ the\ open\ ServerSocket;\ use\ this\r\n\ to\ halt\ a\ running\ jProxy\ thread\r\n
comment7.params=
comment7.target=void\ run()
numComments=8
